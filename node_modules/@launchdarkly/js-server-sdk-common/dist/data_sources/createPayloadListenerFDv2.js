"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPayloadListener = void 0;
const namespaceForKind = (kind) => {
    switch (kind) {
        case 'flag':
            return 'features';
        case 'segment':
            return 'segments';
        default:
            return kind;
    }
};
const createPayloadListener = (dataSourceUpdates, logger, basisReceived = () => { }) => (payload) => {
    // This conversion from FDv2 updates to the existing types used with DataSourceUpdates should be temporary.  Eventually
    // DataSourceUpdates will support update(...) taking in the list of updates.
    if (payload.basis) {
        // convert basis to init param structure
        // TODO: SDK-850 - remove conversion as part of FDv2 Persistence work
        const converted = {};
        payload.updates.forEach((it) => {
            const namespace = namespaceForKind(it.kind);
            if (converted[namespace]) {
                // entry for kind already exists, add key
                converted[namespace][it.key] = Object.assign({ version: it.version, deleted: it.deleted }, it.object);
            }
            else {
                // entry for kind doesn't exist, add kind and key
                converted[namespace] = {
                    [it.key]: Object.assign({ version: it.version, deleted: it.deleted }, it.object),
                };
            }
        });
        logger === null || logger === void 0 ? void 0 : logger.debug('Initializing all data');
        dataSourceUpdates.init(converted, basisReceived);
    }
    else {
        // convert data to upsert param
        // TODO: SDK-850 - remove conversion as part of FDv2 Persistence work
        payload.updates.forEach((it) => {
            const converted = Object.assign({ key: it.key, version: it.version, deleted: it.deleted }, it.object);
            if (it.deleted) {
                logger === null || logger === void 0 ? void 0 : logger.debug(`Deleting ${it.key} in ${it.kind}`);
            }
            else {
                logger === null || logger === void 0 ? void 0 : logger.debug(`Updating ${it.key} in ${it.kind}`);
            }
            dataSourceUpdates.upsert({ namespace: namespaceForKind(it.kind) }, converted, () => { });
        });
    }
};
exports.createPayloadListener = createPayloadListener;
//# sourceMappingURL=createPayloadListenerFDv2.js.map